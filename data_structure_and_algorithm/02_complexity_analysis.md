# 复杂度分析

> 复杂度分析是整个算法学习的精髓。

- 时间复杂度分析
- 空间复杂度分析



## 为什么需要复杂度分析

因为通过统计和监控得到算法执行的时间和占用的内存大小（这种方法被称为事后统计法），存在以下的局限：

- 测试结果非常依赖测试环境
  - 硬件不同对测试结果的影响很大，比如说 在 i5上的执行速度本身比 i3快，

- 测试结果受数据规模的影响很大
  - 有时测试数据规模小，测试结果无法真实地反应算法的性能，比如小规模的数据排序，插入排序可能比快排还快。

所以我们需要不用具体的测试数据分析，就可以粗略地估算算法的执行效率的方法。



## 大O时间复杂度的由来和表示方法

一个规律：所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

**T(n) = O(f(n))**

T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

当n很大时，时间函数中的低阶、常量和系数并不左右增长趋势，所以通常忽略掉公式中常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以可以将 T(n) = O(2n+2) 记为 T(n) = O(n)；将 T(n) = O(2n^2+2n+3) 记为 T(n) = O(n^2)。



##  时间复杂度分析

- 几个分析技巧，并不用记忆：
  - 只关注循环执行次数最多的那一段代码
  - 加法原则：总复杂度等于量级最大的那段代码的复杂度
    如果 T1（n）= O（f（n）），T2（n）=O（g（n））, 则
    T（n） = T1（n）+ T2（n）= O（max(f（n）+ g（n）)）

  - 乘法原则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积，公式为 T（n）= T1（n）* T2（n）= O（f（n）* g（n））

### 常见的时间复杂度

![img](../resource/common_algorithm_complexity.jpg)



常量级时间复杂度 O（1）

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

```c
void cal(int n) {
        int i = 0;
        int j = 0;
        int sum = 0;
        sum = i + j;
}
```



对数阶O（log(n)）

```c++
int i = 1;
while(i < n){
  i = 2 *i;
}
```

变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。

2^x=n

x=log2n

$\log n$



###### 线性对数阶O（nlog（n））

```c
void cal(int n) {
        for (int j = 0; j < n; j++) {
            int i = 1;
            int sum = 0;
            while(i < n){
                i = 2 *i;
            }
        }  
    }
```

至于平方阶、立方阶、k次方阶则是多个循环嵌套而成，这里就不写代码了。

###### 特殊情况O（m+n）、O（m*n）

```c
void cal(int n, int m) {
        for (int i = 0; i < n; i++) {
            //do something
        }
        
        for (int j = 0; j < m; j++) {
            //do something
        }
    }
```



