# 复杂度分析

> 复杂度分析是整个算法学习的精髓。

- 时间复杂度分析
- 空间复杂度分析



## 为什么需要复杂度分析

因为通过统计和监控得到算法执行的时间和占用的内存大小（这种方法被称为事后统计法），存在以下的局限：

- 测试结果非常依赖测试环境
  - 硬件不同对测试结果的影响很大，比如说 在 i5上的执行速度本身比 i3快，

- 测试结果受数据规模的影响很大
  - 有时测试数据规模小，测试结果无法真实地反应算法的性能，比如小规模的数据排序，插入排序可能比快排还快。

所以我们需要不用具体的测试数据分析，就可以粗略地估算算法的执行效率的方法。



## 大O时间复杂度的由来和表示方法

一个规律：所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

**T(n) = O(f(n))**

T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

当n很大时，时间函数中的低阶、常量和系数并不左右增长趋势，所以通常忽略掉公式中常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以可以将 T(n) = O(2n+2) 记为 T(n) = O(n)；将 T(n) = O(2n^2+2n+3) 记为 T(n) = O(n^2)。



##  时间复杂度分析

- 只关注循环执行次数最多的那一段代码

  ```
  int cal(int n){ 
  	int sum = 0;
  	int i = 1;
  	for (; i <= n; ++i){
		sum = sum + i;
  	} 
  	return sum;
  }
  ```
  
  


